# -*- coding: utf-8 -*-
"""TASK01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N5xb1xhPZNqQ3RG3oE5PXhJEYuIUYYqv
"""

# TASK 1: BFS and DFS on a simple graph

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': [],
    'F': []
}
# BFS
def bfs(graph, start):
    visited = []
    queue = [start]
    while queue:
        node = queue.pop(0)
        if node not in visited:
            visited.append(node)
            queue.extend(graph[node])
    return visited
# DFS
def dfs(graph, start, visited=None):
    if visited is None:
        visited = []
    visited.append(start)
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    return visited
print("BFS:", bfs(graph, 'A'))
print("DFS:", dfs(graph, 'A'))

# 1. Import the Matplotlib library
import matplotlib.pyplot as plt

# 2. Create data
X = [1, 2, 3, 4, 5]
Y = [2, 4, 6, 8, 10]

# 3. Create a line plot
plt.plot(X, Y)

# Add title and labels
plt.title("Simple Line Plot")
plt.xlabel("X-axis")
plt.ylabel("Y-axis")

# Add grid lines
plt.grid(True)

# Show the plot
plt.show()

# ðŸ§Š Water Jug Problem using BFS and DFS
import time
from collections import deque

# Jug capacities and goal
jug1 = 4     # 4-liter jug
jug2 = 3     # 3-liter jug
goal = 2     # We need to get exactly 2 liters

# ðŸ‘‰ Function that returns all possible next moves
def next_states(x, y):
    return [
        (jug1, y),  # Fill jug1 completely
        (x, jug2),  # Fill jug2 completely
        (0, y),     # Empty jug1
        (x, 0),     # Empty jug2
        # Pour water from jug1 to jug2
        (x - min(x, jug2 - y), y + min(x, jug2 - y)),
        # Pour water from jug2 to jug1
        (x + min(y, jug1 - x), y - min(y, jug1 - x))
    ]

# ðŸŒ€ BFS (Breadth-First Search)
def bfs():
    start = time.time()          # Start timer
    visited = set()              # To remember visited states
    queue = deque([(0, 0)])      # Start with both jugs empty
    steps = 0                    # Count steps

    while queue:
        x, y = queue.popleft()   # Take first state from queue
        steps += 1
        if (x, y) in visited:    # Skip already visited states
            continue
        visited.add((x, y))      # Mark this state as visited

        if x == goal or y == goal:   # Check if goal reached
            break

        # Add all next possible moves to the queue
        for state in next_states(x, y):
            queue.append(state)

    # Print results
    print("\nBFS Result:")
    print("Steps:", steps)
    print("Time:", round(time.time() - start, 5), "seconds")
    print("Visited States:", len(visited))

# ðŸ§­ DFS (Depth-First Search)
def dfs(x, y, visited, steps):
    steps[0] += 1
    if (x, y) in visited:
        return False
    visited.add((x, y))

    if x == goal or y == goal:   # Goal found
        return True

    # Explore next moves one by one
    for state in next_states(x, y):
        if dfs(state[0], state[1], visited, steps):
            return True
    return False

def run_dfs():
    start = time.time()
    visited = set()
    steps = [0]          # List used so it can change inside dfs()
    dfs(0, 0, visited, steps)

    # Print results
    print("\nDFS Result:")
    print("Steps:", steps[0])
    print("Time:", round(time.time() - start, 5), "seconds")
    print("Visited States:", len(visited))

# ðŸ§® Run both algorithms
bfs()
run_dfs()